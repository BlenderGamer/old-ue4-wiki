<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <link href="https://www.epicgames.com/tos"/>
  <title>
   Actions Based on Mouse Movement - Old UE4 Wiki
  </title>
  <link href="../styles.css" rel="stylesheet"/>
 </head>
 <body>
  <nav id="top-nav">
   <a href="../index.html" title="Home">
    Home
   </a>
  </nav>
  <div class="mw-body" id="content" role="main">
   <a id="top">
   </a>
   <div class="mw-indicators mw-body-content">
   </div>
   <h1 class="firstHeading" id="firstHeading" lang="en">
    Actions Based on Mouse Movement
   </h1>
   <div class="mw-body-content" id="bodyContent">
    <div class="noprint" id="siteSub">
     From Epic Wiki
    </div>
    <div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en">
     <div class="mw-parser-output">
      <p>
       <img alt="MouseLocation.png" class="" height="712" src="../assets/actions-based-on-mouse-movement/0.png" width="1282"/>
      </p>
      <p>
       Authored by: Adam Davis
      </p>
      <h1>
       <span class="mw-headline" id="Overview">
        Overview
       </span>
      </h1>
      <p>
       There has been an increase in kinetic games in recent years, and with this upswing an increased need to track physical movements. One way to simulate that is to get the mouse's location and determine which direction it is moving. The good news is this is extremely easy to set up and can have wide ranging applications. One example would be to set up 4 different melee attacks: an overhead swing, a normal swing, a backhanded swing, and an upwards swing. Which animation is called would depend on which direction the mouse moved, and can be combined with things such as .csv datatables to determine damage and animation speed based on type of swing performed.
      </p>
      <h2>
       <span class="mw-headline" id="Steps_to_recreate">
        Steps to recreate
       </span>
      </h2>
      <ol>
       <li>
        Make an input, in my case I use RMB as an attack button. I highly recommend using a mouse button for this as it is very intuitive.
       </li>
       <li>
        Add a delay with a very low value (.1 works well). This gives you a brief delay between pressing the button and the check to give an accurate depiction of which way the mouse is moving.
       </li>
       <li>
        This branch checks to make sure that the mouse is moving. If the turn rate is greater than the lookup rate, it will register right or left, if the lookup rate is higher than the turn rate, it will register up or down. This gives you four distinct quadrants that you can work with.
        <br/>
        <b>
         Note: Both turn and lookup are float variables set to 0.0. You will want to set these based on your mouse input axis values so they are altered by the values input in the mouse.
        </b>
       </li>
       <li>
        If Look Up ends up being greater than Turn, compare Look Up and 0, if LookUp is &gt; 0, it is going Up (or Down if, like me, you have inverted controls set up), if it is &lt; 0, print the opposite.
       </li>
       <li>
        Do the same thing off of the "false" branch, this time checking your Turn input for Left or Right.
       </li>
      </ol>
      <p>
       <br/>
       It is that simple, once you get this set up you can quickly iterate and alter the functions to suit your needs!
      </p>
     </div>
    </div>
    <div class="visualClear">
    </div>
   </div>
  </div>
 </body>
</html>